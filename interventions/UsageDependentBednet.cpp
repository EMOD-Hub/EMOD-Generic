/***************************************************************************************************

Copyright (c) 2018 Intellectual Ventures Property Holdings, LLC (IVPH) All rights reserved.

EMOD is licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 License.
To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode

***************************************************************************************************/

#include "stdafx.h"
#include "UsageDependentBednet.h"
#include "InterventionFactory.h"
#include "Log.h"
#include "IndividualEventContext.h"
#include "IIndividualHumanContext.h"
#include "RANDOM.h"
#include "DistributionFactory.h"

SETUP_LOGGING( "UsageDependentBednet" )

namespace Kernel
{
    class WaningConfigList : public JsonConfigurable, public IComplexJsonConfigurable
    {
        IMPLEMENT_DEFAULT_REFERENCE_COUNTING()
    public:
        WaningConfigList();

        virtual QueryResult QueryInterface( iid_t iid, void **ppvObject ) { return e_NOINTERFACE; }
        json::QuickBuilder GetSchema() override;
        virtual void ConfigureFromJsonAndKey( const Configuration* inputJson, const std::string& key ) override;
        virtual bool HasValidDefault() const override { return true; }

        const std::vector<WaningConfig*>& GetList() const
        {
            return m_ConfigList;
        }

    protected:
        std::vector<WaningConfig*> m_ConfigList;
    };

    WaningConfigList::WaningConfigList()
        : JsonConfigurable()
        , m_ConfigList()
    {
    }

    json::QuickBuilder WaningConfigList::GetSchema()
    {
        json::QuickBuilder schema( GetSchemaBase() );
        auto tn = JsonConfigurable::_typename_label();
        auto ts = JsonConfigurable::_typeschema_label();
        schema[ tn ] = json::String( "idmType:WaningConfigList" );

        WaningConfig config;

        schema[ ts ] = json::Array();
        schema[ ts ][ 0 ] = config.GetSchema();

        schema["default"] = json::Array();

        return schema;
    }

    void WaningConfigList::ConfigureFromJsonAndKey( const Configuration* inputJson, const std::string& key )
    {
        json::QuickInterpreter qi( (*inputJson)[ key ] );
        try
        {
            json::Array config_array_json( qi.As<json::Array>() );
            for( int i = 0; i < config_array_json.Size(); i++ )
            {
                if( (config_array_json[ i ].Type() == json::NULL_ELEMENT) || json_cast<const json::Object&>(config_array_json[ i ]).Empty() )
                {
                    throw InvalidInputDataException( __FILE__, __LINE__, __FUNCTION__, "'Usage_Config_List' element cannot be empty.");
                }

                json::QuickInterpreter config_qi( config_array_json[ i ] );
                WaningConfig* p_config = new WaningConfig( &config_qi );
                m_ConfigList.push_back( p_config );
            }
        }
        catch( const json::Exception & )
        {
            throw Kernel::JsonTypeConfigurationException( __FILE__, __LINE__, __FUNCTION__, key.c_str(), qi, "Expected ARRAY" );
        }
    }


    // ------------------------------------------------------------------------
    // --- UsageDependentBednet
    // ------------------------------------------------------------------------
    BEGIN_QUERY_INTERFACE_DERIVED( UsageDependentBednet, AbstractBednet )
    END_QUERY_INTERFACE_DERIVED( UsageDependentBednet, AbstractBednet )

    IMPLEMENT_FACTORY_REGISTERED( UsageDependentBednet )

    UsageDependentBednet::UsageDependentBednet()
    : AbstractBednet()
    , m_UsageEffectList()
    , m_TriggerReceived()
    , m_TriggerUsing()
    , m_TriggerDiscard()
    , m_ExpirationDuration( nullptr )
    , m_ExpirationTimer(0.0)
    , m_TimerHasExpired(false)
    {
        m_ExpirationTimer.handle = std::bind( &UsageDependentBednet::Callback, this, std::placeholders::_1 );
    }

    UsageDependentBednet::UsageDependentBednet( const UsageDependentBednet& master )
    : AbstractBednet( master )
    , m_UsageEffectList()
    , m_TriggerReceived( master.m_TriggerReceived )
    , m_TriggerUsing( master.m_TriggerUsing )
    , m_TriggerDiscard( master.m_TriggerDiscard )
    , m_ExpirationDuration( master.m_ExpirationDuration->Clone() )
    , m_ExpirationTimer(master.m_ExpirationTimer)
    , m_TimerHasExpired(master.m_TimerHasExpired)
    {
        for( auto p_effect : master.m_UsageEffectList )
        {
            m_UsageEffectList.push_back( p_effect->Clone() );
        }
        m_ExpirationTimer.handle = std::bind( &UsageDependentBednet::Callback, this, std::placeholders::_1 );
    }

    UsageDependentBednet::~UsageDependentBednet()
    {
        for( auto p_effect : m_UsageEffectList )
        {
            delete p_effect;
        }
        m_UsageEffectList.clear();
        delete m_ExpirationDuration;
    }

    bool UsageDependentBednet::ConfigureUsage( const Configuration * inputJson )
    {
        WaningConfigList usage_config_list;
        initConfigComplexType( "Usage_Config_List", &usage_config_list, UDBednet_Usage_Config_List_DESC_TEXT );

        bool configured = JsonConfigurable::Configure( inputJson ); // AbstractBednet is responsible for calling BaseIntervention::Configure()

        if( configured && !JsonConfigurable::_dryrun )
        {
            int i = 0;
            for( auto p_config : usage_config_list.GetList() )
            {
                std::stringstream param_name;
                param_name << "Usage_Config_List[" << i << "]";

                IWaningEffect* p_effect = WaningEffectFactory::getInstance()->CreateInstance( p_config->_json,
                                                                                              inputJson->GetDataLocation(),
                                                                                              param_name.str().c_str() );
                m_UsageEffectList.push_back( p_effect );
                ++i;
            }
        }

        return configured;
    }

    bool UsageDependentBednet::ConfigureEvents( const Configuration * inputJson )
    {
        DistributionFunction::Enum expiration_function( DistributionFunction::CONSTANT_DISTRIBUTION );
        initConfig("Expiration_Period_Distribution", expiration_function, inputJson, MetadataDescriptor::Enum("Expiration_Distribution_Type", UDBednet_Expiration_Distribution_Type_DESC_TEXT, MDD_ENUM_ARGS(DistributionFunction)));                 
        m_ExpirationDuration = DistributionFactory::CreateDistribution( this, expiration_function, "Expiration_Period", inputJson );

        initConfig( "Received_Event", m_TriggerReceived, inputJson, MetadataDescriptor::Enum("Received_Event", UDBednet_Received_Event_DESC_TEXT, MDD_ENUM_ARGS( EventTrigger ) ) );
        initConfig( "Using_Event",    m_TriggerUsing,    inputJson, MetadataDescriptor::Enum("Using_Event",    UDBednet_Using_Event_DESC_TEXT,    MDD_ENUM_ARGS( EventTrigger ) ) );
        initConfig( "Discard_Event",  m_TriggerDiscard,  inputJson, MetadataDescriptor::Enum("Discard_Event",  UDBednet_Discard_Event_DESC_TEXT,  MDD_ENUM_ARGS( EventTrigger ) ) );

        return JsonConfigurable::Configure( inputJson ); // AbstractBednet is responsible for calling BaseIntervention::Configure()
    }

    bool UsageDependentBednet::Distribute( IIndividualHumanInterventionsContext *context,
                                           ICampaignCostObserver * const pCCO )
    {
        bool distributed = AbstractBednet::Distribute( context, pCCO );
        if( distributed )
        {
            m_ExpirationTimer = m_ExpirationDuration->Calculate( context->GetParent()->GetRng() );
            BroadcastEvent( m_TriggerReceived );

            // ----------------------------------------------------------------------------
            // --- Assuming dt=1.0 and decrementing timer so that a timer of zero expires
            // --- when it is distributed but is not used.  A timer of one should be used
            // --- the day it is distributed but expire:
            // ---    distributed->used->expired on all same day
            // ----------------------------------------------------------------------------
            m_ExpirationTimer.Decrement( 1.0 );
        }
        return distributed;
    }

    bool UsageDependentBednet::IsUsingBednet() const
    {
        float usage_effect = GetEffectUsage();

        // Check expiratin in case it expired when it was distributed
        bool is_using = !m_TimerHasExpired && parent->GetRng()->SmartDraw( usage_effect );

        if( is_using )
        {
            BroadcastEvent( m_TriggerUsing );
        }

        return is_using;
    }

    void UsageDependentBednet::UpdateUsage( float dt )
    {
        for( auto p_effect : m_UsageEffectList )
        {
            p_effect->Update( dt );
        }
    }

    float UsageDependentBednet::GetEffectUsage() const
    {
        float usage_effect = 1.0;
        for( auto p_effect : m_UsageEffectList )
        {
            usage_effect *= p_effect->Current();
        }
        return usage_effect;
    }

    bool UsageDependentBednet::CheckExpiration( float dt )
    {
        m_ExpirationTimer.Decrement( dt );

        return m_TimerHasExpired;
    }

    void UsageDependentBednet::Callback( float dt )
    {
        m_TimerHasExpired = true;
    }

    void UsageDependentBednet::SetExpired( bool isExpired )
    {
        AbstractBednet::SetExpired( isExpired );
        if( Expired() )
        {
            BroadcastEvent( m_TriggerDiscard );
        }
    }

    void UsageDependentBednet::SetContextTo( IIndividualHumanContext *context )
    {
        AbstractBednet::SetContextTo( context );
        for( auto p_effect : m_UsageEffectList )
        {
            p_effect->SetContextTo( context );
        }
    }


    REGISTER_SERIALIZABLE( UsageDependentBednet );

    void UsageDependentBednet::serialize( IArchive& ar, UsageDependentBednet* obj )
    {
        AbstractBednet::serialize( ar, obj );
        UsageDependentBednet& bednet = *obj;

        ar.labelElement( "m_UsageEffectList" ) & bednet.m_UsageEffectList;
        LOG_ERR( "TBD: Serialize enum." );
        ar.labelElement( "m_TriggerReceived" ) & (uint32_t&)bednet.m_TriggerReceived;
        ar.labelElement( "m_TriggerUsing"    ) & (uint32_t&)bednet.m_TriggerUsing;
        ar.labelElement( "m_TriggerDiscard"  ) & (uint32_t&)bednet.m_TriggerDiscard;
        ar.labelElement( "m_ExpirationTimer" ) & bednet.m_ExpirationTimer;
        ar.labelElement( "m_TimerHasExpired" ) & bednet.m_TimerHasExpired;
    }
}
